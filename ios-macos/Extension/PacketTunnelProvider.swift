import NetworkExtension
import os.log

@objc class PacketTunnelProvider: NEPacketTunnelProvider {

    private let log = OSLog(subsystem: "com.hankyeomans.ztna-agent", category: "Tunnel")

    override func startTunnel(options: [String : NSObject]?, completionHandler: @escaping (Error?) -> Void) {
        os_log("Starting tunnel...", log: log)
        
        // 1. Configure Tunnel Settings (Virtual Interface)
        let settings = NEPacketTunnelNetworkSettings(tunnelRemoteAddress: "127.0.0.1")
        settings.ipv4Settings = NEIPv4Settings(addresses: ["100.64.0.1"], subnetMasks: ["255.255.255.255"])
        
        // Split Tunneling: Route ZTNA virtual service range (10.100.0.0/24) through tunnel
        // 10.100.0.1 = echo-service (UDP 9999)
        let route = NEIPv4Route(destinationAddress: "10.100.0.0", subnetMask: "255.255.255.0")
        settings.ipv4Settings?.includedRoutes = [route]
        
        settings.dnsSettings = NEDNSSettings(servers: ["8.8.8.8"])
        
        self.setTunnelNetworkSettings(settings) { [weak self] error in
            if let error = error {
                os_log("Failed to set tunnel settings: %{public}@", log: self?.log ?? .default, error.localizedDescription)
                completionHandler(error)
                return
            }
            
            os_log("Tunnel settings applied successfully.", log: self?.log ?? .default)
            
            // 2. Start reading packets
            self?.readPackets()
            
            completionHandler(nil)
        }
    }

    override func stopTunnel(with reason: NEProviderStopReason, completionHandler: @escaping () -> Void) {
        os_log("Stopping tunnel...", log: log)
        completionHandler()
    }

    override func handleAppMessage(_ messageData: Data, completionHandler: ((Data?) -> Void)? = nil) {
        // Handle IPC from the main app if needed
        completionHandler?(nil)
    }

    override func sleep(completionHandler: @escaping () -> Void) {
        completionHandler()
    }

    override func wake() {
        // Add code to be executed when the system wakes up
    }
    
    // MARK: - Packet Loop
    
    private func readPackets() {
        // Read packets from the virtual interface (packets generated by apps)
        self.packetFlow.readPackets { [weak self] (packets, protocols) in
            guard let self = self else { return }
            
            for (i, packetData) in packets.enumerated() {
                // Ensure it's an IPv4 packet (AF_INET = 2)
                let protocolFamily = protocols[i].int32Value
                if protocolFamily == AF_INET {
                     self.processIPPacket(packetData)
                }
            }
            
            // Continue the loop
            self.readPackets()
        }
    }
    
    private func processIPPacket(_ data: Data) {
        // Pass the raw packet data to Rust FFI
        // 'data' is a standard IP packet
        
        let action = data.withUnsafeBytes { (ptr: UnsafeRawBufferPointer) -> PacketAction in
            guard let baseAddress = ptr.baseAddress else { return PacketActionForward }
            // Call the C/Rust function
            // Note: We need to ensure the Swift Bridging Header is correctly imported in the target settings
            return process_packet(baseAddress.assumingMemoryBound(to: UInt8.self), data.count)
        }
        
        switch action {
        case PacketActionDrop:
            os_log("Dropping packet (Rust decision)", log: log)
            // Do nothing, implicitly dropping it by not writing it processing it further
            
        case PacketActionForward:
            // For a VPN, "Forwarding" usually means:
            // 1. Encapsulate and send to remote (if it's an outbound packet)
            // 2. Write back to OS (if it came from remote)
            
            // Since this is a "Hello World" loopback/logger, and we don't have a real remote yet,
            // we will just log it.
            // WARNING: If we write it back to packetFlow without changing it, we might create a loop 
            // if the routing table sends it back to us.
            // For now, we are valid 'sinks' for this traffic.
            break
        default:
            break
        }
    }
}
